% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dbsnp.R
\name{repair_rsid}
\alias{repair_rsid}
\title{Use CHR and POS to get RSID from dbSNP v.155}
\usage{
repair_rsid(
  tbl,
  build = c("NA", "37", "38"),
  dbsnp_path,
  add_missing_build = TRUE
)
}
\arguments{
\item{tbl}{a \code{\link[dplyr:reexports]{dplyr::tibble()}}, formated with \code{\link[=tidyGWAS_columns]{tidyGWAS_columns()}}}

\item{build}{If you are sure of what genome build ('37' or '38'), can be used to skip \code{\link[=infer_build]{infer_build()}} and speed up computation}

\item{dbsnp_path}{filepath to the dbSNP155 directory (untarred dbSNP155.tar)}

\item{add_missing_build}{Should the build which the sumstats are NOT on also be added in?}
}
\value{
a \code{\link[dplyr:reexports]{dplyr::tibble()}} with columns \code{CHR}, \code{POS}, \code{POS_37} and \code{CHR_37} added
}
\description{
\code{\link[=repair_rsid]{repair_rsid()}} and \code{\link[=repair_chr_pos]{repair_chr_pos()}} work similary, but assumes that either
rsid or chr_pos is missing.

The functions first check which build the input data is in using \code{\link[=infer_build]{infer_build()}}.
Secondly, it maps each row to dbSNP using either rsid or chr_pos. Rows without a
match are flagged with \code{no_dbsnp_entry} = TRUE. Subsequently, rows where
EffectAllele and OtherAllele do not match the alleles in dbSNP are flagged with
\code{incompat_alleles} = TRUE.
Lastly, whichever build was missing is added to the data.
}
\examples{
\dontrun{
sumstat_df <- repair_rsid(sumstat, bsgenome_list)
}

}
