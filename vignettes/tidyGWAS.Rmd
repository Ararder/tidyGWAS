---
title: "tidyGWAS"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{tidyGWAS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(tidyGWAS)
library(dplyr)
```

# Downloaded reference files

tidyGWAS uses a version of dbSNP transformed into [parquet](https://arrow.apache.org/docs/r/) files, which is needed to

perform validation and reparation of CHR, POS and RSID. These files can be downloaded here:\
<https://drive.google.com/drive/folders/1ZcwnQtwWC476a5OiAYfSR2qCX6PiqhV3>

```{r, eval=FALSE}
googledrive::drive_deauth()
file_id <- googledrive::as_id("1hg6jxQUj6UmEdLIH46md7eJcgfVlzmNn")
googledrive::drive_download(file_id)

```

```{bash, eval=FALSE}
DIRPATH = "dbsnp155"
tar -xvf dbSNP155.tar $DIRPATH

```

# Quick start

```{r, eval=FALSE}
devtools::install_github("ararder/tidyGWAS")
# or
remotes::install_github("ararder/tidyGWAS")
```

The GWAS summary statistics file can be provided in-memory as a data.table / anything that can be coerced to a tibble or a filepath that can be read with data.table::fread. We will use the 100k random rows from the PGC wave 3 schizophrenia [GWAS](https://pgc.unc.edu/for-researchers/download-results/) as an example file.

Here, the column names have already been renamed to the correct format.

```{r}
example_file <- tidyGWAS::test_file
example_file
```

## Creating the correct column names

If our input file had column names that were not in the correct format, you can use `tidyGWAS_columns()`\` to first rename columns to the correct format. This can also be useful because `tidyGWAS_columns()` will drop any columns not matching the correct format, so you can quickly identify any mislabelled columns

```{r}
# what if we have a file where POS was named bp, and B was named BETA?
# tidyGWAS will not recognize these as valid column names and would drop them.
wrong_colnames <- rename(example_file, bp = POS, BETA = B)

# we can use tidyGWAS_columns to specify current names:
correct_names <- tidyGWAS_columns(
  # first argument is the data.frame
  tbl = wrong_colnames, 
  # then any column which is not correctly named:
  POS = "bp",
  B = "BETA"
  )

correct_names
```

# Running tidyGWAS

tidyGWAS requires one mandatory argument: `tbl` , which is either a data.frame, or filepath

```{r, eval = FALSE}
# input the filepath where you untarred the downloaded reference files
path_to_dbsnp = ""
tidyGWAS(correct_names, dbsnp_path = path_to_dbsnp)

```

You can run tidyGWAS without dbSNP filtering. This will substantially quicker. By default, all outputted files are stored in a `tempdir()`. You can add `outdir = "filepath/to_dir/"` to automatically copy over files after finished execution.

tidyGWAS cannot find all rows that were removed. This is because it removed some rows where RSID was coded as CHR:POS:REF:ALT. Normally, RSID would be repaired using dbSNP, but since we passed `use_dbnp = FALSE`, these rows are instead dropped.

```{r, eval = FALSE}
my_outdir <- paste0(tempdir(), "all_my_gwas_sumstats", sep = "/")

# We can also add logfile = TRUE to save output to a logfile
tidyGWAS(correct_names, use_dbsnp = FALSE, outdir = my_outdir, logfile = TRUE, dbsnp_path = path_to_dbsnp)
```

## The functions within

tidyGWAS exposes several smaller functions that can help when interactively working with sumstats.

## Getting B and SE from Z, N and EAF

`repair_stats()` can be used to add any missing statistics column, such as P, Z, B or SE, depending on which columns exist. Note that there some

```{r}
# Has Z , EAF and N, but not B and SE (Which are commonly used for PRS)
tmp <- dplyr::mutate(test_file, Z = B/SE, N = CaseN + ControlN) |> 
  dplyr::select(-B, -SE)
repaired <- repair_stats(tmp)

# the Betas will be on a standardized scale, and can therefore be different
# than what was initially there
dplyr::inner_join(test_file, repaired,by = "RSID") |> dplyr::select(B.x, B.y) |> 
  dplyr::summarise(cor(B.x, B.y))


# Getting Z, if you only have B and P

```

```{r}
tmp <-  dplyr::select(test_file,  -SE) |> 
  repair_stats()
```

## Identifying incorrect RSIDs

uses a regex to identify any non RrSs rows.

```{r, eval = FALSE}
flag_incorrect_rsid_format(test_file) |> 
  dplyr::filter(invalid_rsid)

```

## A fast function for finding duplications in RSID or CHR

```{r}
flag_duplicates(test_file, column = "rsid")
# or 
flag_duplicates(test_file, column = "chr_pos")


```

### working with dbSNP

Sometimes the same CHR and POS maps to multiple RSIDs. Currently, we resolve this by slecting the smallest RSID

```{r}
#  CHR        POS RSID         ref_allele alt_alleles
#   <chr>    <int> <chr>        <chr>      <list>     
# 1 1     39491595 rs10157617   T          <chr [2]>  
# 2 1     39491595 rs1638449573 T          <chr [1]>  
# 3 1     39491595 rs1638449625 T          <chr [1]>  
# 4 1     39491595 rs1638449683 T          <chr [1]>  

```

# Using bsgenome backend (depreciated)

```{r}

# if you want to be able to repair CHR:POS or RSID, you need to download the following
# bioconductor packages:
if (!require("BiocManager", quietly = TRUE)) install.packages("BiocManager")
BiocManager::install(version = "3.16")
BiocManager::install("BSgenome")
BiocManager::install("Biostrings")
BiocManager::install("GenomicRanges")
BiocManager::install("BSgenome.Hsapiens.1000genomes.hs37d5")
BiocManager::install("BSgenome.Hsapiens.NCBI.GRCh38")
BiocManager::install("SNPlocs.Hsapiens.dbSNP155.GRCh37")
BiocManager::install("SNPlocs.Hsapiens.dbSNP155.GRCh38")

```
