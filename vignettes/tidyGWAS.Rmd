---
title: "tidyGWAS"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{tidyGWAS}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Installation

tidyGWAS is not yet on CRAN. To install, you need to use
`devtools::install_github()` or `remotes::install_github()`

```{r, eval = FALSE}
devtools::install_github("ararder/tidyGWAS")
remotes::install_github("ararder/tidyGWAS")
```

Secondly, you will need to download the reference data. tidyGWAS uses a
slightly edited version of dbSNP v155, that is available
[here](https://zenodo.org/records/14697504).

```{bash, eval = FALSE}
wget https://zenodo.org/records/16639374/files/dbSNP155.tar
tar -xvf dbSNP155.tar

```

## Using an apptainer or docker container instead

You can skip the installation step by using a docker container with
docker or apptainer.

```{bash, eval = FALSE}
# using apptainer
apptainer pull docker://arvhar/tidygwas:latest
apptainer shell ~/tidygwas_latest.sif

# using docker 
docker run arvhar/tidygwas:latest


```

# NEWS

With the release of **tidyGWAS 1.0**, the package now supports automatic
column-name guessing as well as automatic detection of file delimiter,
using `data.table::fread()`. This means that the `delim` argument has
been superseded and it's often no longer nessecary to pass the names of
the input column names with the `column_names` argument. But remember
to double check the logfile that the column names were parsed correctly.

# Quick start

This is what a typical call to `tidyGWAS()` will look like. A detailed
explanation of the different arguments follows.

```{r, eval=FALSE}
# we setup a directory where we will store all summary statistics cleaned by tidyGWAS
gwas_folder <- tempfile()
# provide the filepath to the name of a directory that tidyGWAS will create.
outdir <- paste0(gwas_folder, "gwasName")

cleaned <- tidyGWAS(
  tbl = "/filepath/to/sumstats", 
  dbsnp_path = dsnp_path,
  # Number of samples are missing, so manually impute
  CaseN = 54000,
  ControlN = 73000,
  logfile=TRUE,
  output_dir = outdir
  )
```

# Tutorial

tidyGWAS now supports directly downloading files from GWAS catalog or
providing URLs.

The first argument to tidyGWAS is `tbl`, and should be one off

1.  A [GWAS catalog](https://www.ebi.ac.uk/gwas/) study id. For example,
    "[GCST90101808](https://www.ebi.ac.uk/gwas/studies/GCST90101808)".
    The full summary statistics needs to be available.
2.  A webpage URL to a downloadable file. For example, the FinnGEN R[12
    depression](https://storage.googleapis.com/finngen-public-data-r12/summary_stats/release/finngen_R12_F5_DEPRESSIO.gz)
    release
3.  A local filepath. For example "\~/summary_stats/raw/trait_x.tsv.gz"
4.  An in-memory data.frame.

```{r, eval = FALSE}
library(tidyGWAS)
# we use the dummy version of dbSNP that comes with the package
dbsnp_path <- system.file("extdata/dbSNP155", package = "tidyGWAS")

# a dummy sumstats with 100 000 rows
gwas <- system.file("extdata/sumstats.tsv.gz", package = "tidyGWAS")
# store the results in a temporary directory
out <- tempfile()

# using a GWAS catalog study ID
tidyGWAS(
  tbl = "GCST90101808",
  dbsnp_path = dbsnp_path,
  output_dir = "finnGEN_MDD_R12"
)

# using a URL
tidyGWAS(
  tbl = "https://storage.googleapis.com/finngen-public-data-r12/summary_stats/release/finngen_R12_F5_DEPRESSIO.gz",
  dbsnp_path = dbsnp_path,
  output_dir = "finnGEN_MDD_R12"
)

# using a local flepath
gwas <- system.file("extdata/sumstats.tsv.gz", package = "tidyGWAS")
tidyGWAS(
  tbl = gwas,
  dbsnp_path = dbsnp_path,
  output_dir = "test_sumstat"
)

# or an in-memory data.frame
df = read.table(gwas)
tidyGWAS(
  tbl = df,
  dbsnp_path = dbsnp_path,
  output_dir = "test_sumstat"
)


```

## An example call
Here's what the output of tidyGWAS looks like, using the test file provided
with tidyGWAS
```{r}
library(tidyGWAS)
tidyGWAS(
  tbl = system.file("extdata/sumstats.tsv.gz", package = "tidyGWAS"),
  dbsnp_path = system.file("extdata/dbSNP155", package = "tidyGWAS"),
  output_dir = tempfile()
)
```



## Manually setting column names

tidyGWAS will attempt to guess the column names of the input file.
Always take a look at the logfile if it's the first time you are using
that particular format. Sometimes the automatic parsing fails, like in the example
below

```{r}
testdf <- arrow::read_tsv_arrow(system.file("extdata/sumstats.tsv.gz", package = "tidyGWAS"))

# nonsense names
names(testdf) <- c("CHROM_X", "BP_NEW", "RsID", "A1", "A2", "B","SE", "EAF","INFO", "P", "CaseN", "ControlN", "rowid")

# Wit
tryCatch(
  tidyGWAS(
    tbl = testdf,
    dbsnp_path = system.file("extdata/dbSNP155", package = "tidyGWAS"),
    output_dir = tempfile()
  ),
  error = function(e) {
    message("tidyGWAS failed: ", e$message)
    NULL
  }
)
```

If you use column_names, those columns will be renamed, following by an automatic attempt at parsing the remaining column names.

```{r}
testdf <- arrow::read_tsv_arrow(system.file("extdata/sumstats.tsv.gz", package = "tidyGWAS"))

# nonsense names
names(testdf) <- c("CHROM_X", "BP_NEW", "RsID", "A1", "A2", "B","SE", "EAF","INFO", "P", "CaseN", "ControlN", "rowid")
out <- tempfile()
tidyGWAS(
  tbl = testdf,
  dbsnp_path = system.file("extdata/dbSNP155", package = "tidyGWAS"),
  output_dir = out,
  column_names = list(
    CHR = "CHROM_X",
    POS = "BP_NEW",
    RSID = "RsID"
  )
)
```



### Output files

tidyGWAS returns all its output in a directory.

```{r}
fs::dir_tree(out)
```

That's a lot of files!

1.  Removed rows are stored in `pipeline/removed_*`

2.  `metadata.yaml` contains metadata about the execution

3.  `raw` contains the summary statistics ***before*** any munging was
    done. Useful to reproduce, or to identify why rows were removed.

4.  `tidyGWAS_hivestyle` contains the cleaned summary statistics, in
    something called a [hivestyle
    partition](https://arrow.apache.org/docs/r/articles/dataset.html),
    by default. The motivation for this is detailed further
    [down](#hivestyle-partitioning) in the vignette. If you just want a
    standard csv file, use `output_format="csv"` or
    `output_format="parquet"`

5.  To read in the cleaned summary statistics:

    `df <- arrow::open_dataset(paste0(out, "/tidyGWAS_hivestyle")) |> dplyr::collect()`

### The tidyGWAS columns

tidyGWAS uses the following column names:

-   CHR

-   POS

-   RSID

-   EffectAllele

-   OtherAllele

-   EAF

-   B

-   SE

-   P

-   CaseN

-   ControlN

-   N

-   EffectiveN

-   INFO

-   Z

**Note**:

If your RSID column is in the format CHR:BP:A1:A2, you can still pass it
as an RSID column. tidyGWAS automatically detects and splits apart the
values.

### Inputting sample size columns

Often, the sample size column is missing from the summary statistics,
and you provide it manually. tidyGWAS has three arguments that can be
used to manually set the sample size if it's missing from the original
file:

-   `CaseN`

-   `ControlN`

-   `N`

```{r, eval = FALSE}

cleaned <- tidyGWAS(
  tbl = sumstats, 
  dbsnp_path = dbsnp_path,
  # CaseN, ControlN and N can all be used to set sample size
  CaseN = 400,
  ControlN = 800,
  N = 1200
  )


```

### Reading in files

If you pass a filepath to tidyGWAS, it will attempt to read in the file
with `data.table::fread()`. If you need to pass custom arguments to fread to make
the parsing correct, you can the arguments through `...`.


```{r, eval=FALSE}

cleaned <- tidyGWAS(
  tbl = "filepath/to/gwas/ondisk.csv",
  # fread has argument `skip`. Let's pretend i want to skip the first 100 rows
  skip = 100.
  dbsnp_path = dbsnp_path,
)
```


# Hivestyle-partitioning {#hivestyle-partitioning}

The default output format is a hivestyle format using .parquet files.
See for example
[here](https://arrow.apache.org/docs/r/articles/dataset.html) for some
motivation for this. In essence, this format will significantly speed up
other downstream applications such as meta-analysis, LD querying and
other analyses.

### Variant identity

TidyGWAS will add the following columns dealing with variant ID, in
addition to saving and validating all valid columns in the input file.

1.  `CHR` Chromosome. The same across both builds

2.  `POS_38`, `POS_37` genomic position on GRCh38 and GRCh37

3.  `RSID` variant ID from dbSNP

4.  `REF_37`, `REF_38` is the reference genome allele on GRCh38 and
    GRCh37

5.  `multi_allelic` is a TRUE/FALSE column that flag rows that were
    multi-allelic IN the summary statistics NOT whether there are
    multiple alleles in dbSNP. (TRUE corresponds to multi allelic).

6.  `rowid` maps each row back to the inputted summary statistics the
    file in `raw`, so that any row can be mapped back to it's original
    values.

7.  `indel` TRUE/FALSE whether the variant is of type INsertion/DELetion

8.  All other valid columns in the input summary statistics file

9.  If possible `repair_stats()` will add statistics columns such as
    `B, P, SE, Z`, if they are missing and possible to repair.

# Parallel computation

tidyGWAS automatically detects the number of cores. In some cases, for
example when running tidyGWAS in a HPC cluster, you might need to
manually set the number of cores, which can be done using the
`OMP_NUM_THREADS` variable. This should not be a larger number of cores
than what you have requested in your HPC job (in the example below, the
"--cpus-per-task" flag)

```{bash, eval=FALSE}

#SBATCH --mem=60gb
#SBATCH --time=24:0:00
#SBATCH --cpus-per-task 8
export OMP_NUM_THREADS=8

outdir=$(pwd)
gwas=$outdir/my_gwas.tsv.gz
dbsnp_files="dbSNP155"
Rscript -e "tidyGWAS(commandArgs(trailingOnly = TRUE)[1],  dbsnp_path = commandArgs(trailingOnly = TRUE)[2],output_dir = commandArgs(trailingOnly = TRUE)[3], logfile=TRUE)" $gwas $dbsnp_files $outdir

```

# Computational cost and memory usage

Memory use and time scales with the size of the summary statistics. From
running tidyGWAS, here's an estimation. Especially, if the summary
statistics are missing CHR and POS, tidyGWAS will require additional
memory. 1. 10 million rows \~ 5-15gb 2. 40 million rows 10-40gb 3. 60
million rows 65-85gb
